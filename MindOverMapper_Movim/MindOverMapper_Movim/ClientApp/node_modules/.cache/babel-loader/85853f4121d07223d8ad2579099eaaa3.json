{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { AbstractComponent2, DISPLAYNAME_PREFIX, Keys, Menu, Utils } from \"@blueprintjs/core\";\nimport { executeItemsEqual, getActiveItem, getCreateNewItem, isCreateNewItem, renderFilteredItems } from \"../../common\";\n\nvar QueryList =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(QueryList, _super);\n\n  function QueryList(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.refHandlers = {\n      itemsParent: function (ref) {\n        return _this.itemsParentRef = ref;\n      }\n    };\n    /**\n     * Flag indicating that we should check whether selected item is in viewport\n     * after rendering, typically because of keyboard change. Set to `true` when\n     * manipulating state in a way that may cause active item to scroll away.\n     */\n\n    _this.shouldCheckActiveItemInViewport = false;\n    /**\n     * The item that we expect to be the next selected active item (based on click\n     * or key interactions). When scrollToActiveItem = false, used to detect if\n     * an unexpected external change to the active item has been made.\n     */\n\n    _this.expectedNextActiveItem = null;\n    /** default `itemListRenderer` implementation */\n\n    _this.renderItemList = function (listProps) {\n      var _a = _this.props,\n          initialContent = _a.initialContent,\n          noResults = _a.noResults; // omit noResults if createNewItemFromQuery and createNewItemRenderer are both supplied, and query is not empty\n\n      var maybeNoResults = _this.isCreateItemRendered() ? null : noResults;\n      var menuContent = renderFilteredItems(listProps, maybeNoResults, initialContent);\n      var createItemView = _this.isCreateItemRendered() ? _this.renderCreateItemMenuItem(_this.state.query) : null;\n\n      if (menuContent == null && createItemView == null) {\n        return null;\n      }\n\n      return React.createElement(Menu, {\n        ulRef: listProps.itemsParentRef\n      }, menuContent, createItemView);\n    };\n    /** wrapper around `itemRenderer` to inject props */\n\n\n    _this.renderItem = function (item, index) {\n      if (_this.props.disabled !== true) {\n        var _a = _this.state,\n            activeItem = _a.activeItem,\n            query = _a.query;\n        var matchesPredicate = _this.state.filteredItems.indexOf(item) >= 0;\n        var modifiers = {\n          active: executeItemsEqual(_this.props.itemsEqual, getActiveItem(activeItem), item),\n          disabled: isItemDisabled(item, index, _this.props.itemDisabled),\n          matchesPredicate: matchesPredicate\n        };\n        return _this.props.itemRenderer(item, {\n          handleClick: function (e) {\n            return _this.handleItemSelect(item, e);\n          },\n          index: index,\n          modifiers: modifiers,\n          query: query\n        });\n      }\n\n      return null;\n    };\n\n    _this.renderCreateItemMenuItem = function (query) {\n      var activeItem = _this.state.activeItem;\n\n      var handleClick = function (evt) {\n        _this.handleItemCreate(query, evt);\n      };\n\n      var isActive = isCreateNewItem(activeItem);\n      return Utils.safeInvoke(_this.props.createNewItemRenderer, query, isActive, handleClick);\n    };\n\n    _this.handleItemCreate = function (query, evt) {\n      // we keep a cached createNewItem in state, but might as well recompute\n      // the result just to be sure it's perfectly in sync with the query.\n      var item = Utils.safeInvoke(_this.props.createNewItemFromQuery, query);\n\n      if (item != null) {\n        Utils.safeInvoke(_this.props.onItemSelect, item, evt);\n\n        _this.setQuery(\"\", true);\n      }\n    };\n\n    _this.handleItemSelect = function (item, event) {\n      _this.setActiveItem(item);\n\n      Utils.safeInvoke(_this.props.onItemSelect, item, event);\n\n      if (_this.props.resetOnSelect) {\n        _this.setQuery(\"\", true);\n      }\n    };\n\n    _this.handlePaste = function (queries) {\n      var _a = _this.props,\n          createNewItemFromQuery = _a.createNewItemFromQuery,\n          onItemsPaste = _a.onItemsPaste;\n      var nextActiveItem;\n      var nextQueries = []; // Find an exising itemÂ that exactly matches each pasted value, or\n      // create a new item if possible. Ignore unmatched values if creating\n      // items is disabled.\n\n      var pastedItemsToEmit = [];\n\n      for (var _i = 0, queries_1 = queries; _i < queries_1.length; _i++) {\n        var query = queries_1[_i];\n        var equalItem = getMatchingItem(query, _this.props);\n\n        if (equalItem !== undefined) {\n          nextActiveItem = equalItem;\n          pastedItemsToEmit.push(equalItem);\n        } else if (_this.canCreateItems()) {\n          var newItem = Utils.safeInvoke(createNewItemFromQuery, query);\n\n          if (newItem !== undefined) {\n            pastedItemsToEmit.push(newItem);\n          }\n        } else {\n          nextQueries.push(query);\n        }\n      } // UX nicety: combine all unmatched queries into a single\n      // comma-separated query in the input, so we don't lose any information.\n      // And don't reset the active item; we'll do that ourselves below.\n\n\n      _this.setQuery(nextQueries.join(\", \"), false); // UX nicety: update the active item if we matched with at least one\n      // existing item.\n\n\n      if (nextActiveItem !== undefined) {\n        _this.setActiveItem(nextActiveItem);\n      }\n\n      Utils.safeInvoke(onItemsPaste, pastedItemsToEmit);\n    };\n\n    _this.handleKeyDown = function (event) {\n      var keyCode = event.keyCode;\n\n      if (keyCode === Keys.ARROW_UP || keyCode === Keys.ARROW_DOWN) {\n        event.preventDefault();\n\n        var nextActiveItem = _this.getNextActiveItem(keyCode === Keys.ARROW_UP ? -1 : 1);\n\n        if (nextActiveItem != null) {\n          _this.setActiveItem(nextActiveItem);\n        }\n      }\n\n      Utils.safeInvoke(_this.props.onKeyDown, event);\n    };\n\n    _this.handleKeyUp = function (event) {\n      var onKeyUp = _this.props.onKeyUp;\n      var activeItem = _this.state.activeItem; // using keyup for enter to play nice with Button's keyboard clicking.\n      // if we were to process enter on keydown, then Button would click itself on keyup\n      // and the popvoer would re-open out of our control :(.\n\n      if (event.keyCode === Keys.ENTER) {\n        event.preventDefault();\n\n        if (activeItem == null || isCreateNewItem(activeItem)) {\n          _this.handleItemCreate(_this.state.query, event);\n        } else {\n          _this.handleItemSelect(activeItem, event);\n        }\n      }\n\n      Utils.safeInvoke(onKeyUp, event);\n    };\n\n    _this.handleQueryChange = function (event) {\n      var query = event == null ? \"\" : event.target.value;\n\n      _this.setQuery(query);\n\n      Utils.safeInvoke(_this.props.onQueryChange, query, event);\n    };\n\n    var _a = props.query,\n        query = _a === void 0 ? \"\" : _a;\n    var createNewItem = Utils.safeInvoke(props.createNewItemFromQuery, query);\n    var filteredItems = getFilteredItems(query, props);\n    _this.state = {\n      activeItem: props.activeItem !== undefined ? props.activeItem : getFirstEnabledItem(filteredItems, props.itemDisabled),\n      createNewItem: createNewItem,\n      filteredItems: filteredItems,\n      query: query\n    };\n    return _this;\n  }\n\n  QueryList.ofType = function () {\n    return QueryList;\n  };\n\n  QueryList.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        items = _a.items,\n        renderer = _a.renderer,\n        _b = _a.itemListRenderer,\n        itemListRenderer = _b === void 0 ? this.renderItemList : _b;\n\n    var _c = this.state,\n        createNewItem = _c.createNewItem,\n        spreadableState = tslib_1.__rest(_c, [\"createNewItem\"]);\n\n    return renderer(tslib_1.__assign({}, spreadableState, {\n      className: className,\n      handleItemSelect: this.handleItemSelect,\n      handleKeyDown: this.handleKeyDown,\n      handleKeyUp: this.handleKeyUp,\n      handlePaste: this.handlePaste,\n      handleQueryChange: this.handleQueryChange,\n      itemList: itemListRenderer(tslib_1.__assign({}, spreadableState, {\n        items: items,\n        itemsParentRef: this.refHandlers.itemsParent,\n        renderItem: this.renderItem\n      }))\n    }));\n  };\n\n  QueryList.prototype.componentDidUpdate = function (prevProps) {\n    var _this = this;\n\n    if (this.props.activeItem !== undefined && this.props.activeItem !== this.state.activeItem) {\n      this.shouldCheckActiveItemInViewport = true;\n      this.setState({\n        activeItem: this.props.activeItem\n      });\n    }\n\n    if (this.props.query != null && this.props.query !== prevProps.query) {\n      // new query\n      this.setQuery(this.props.query, this.props.resetOnQuery, this.props);\n    } else if ( // same query (or uncontrolled query), but items in the list changed\n    !Utils.shallowCompareKeys(this.props, prevProps, {\n      include: [\"items\", \"itemListPredicate\", \"itemPredicate\"]\n    })) {\n      this.setQuery(this.state.query);\n    }\n\n    if (this.shouldCheckActiveItemInViewport) {\n      // update scroll position immediately before repaint so DOM is accurate\n      // (latest filteredItems) and to avoid flicker.\n      requestAnimationFrame(function () {\n        return _this.scrollActiveItemIntoView();\n      }); // reset the flag\n\n      this.shouldCheckActiveItemInViewport = false;\n    }\n  };\n\n  QueryList.prototype.scrollActiveItemIntoView = function () {\n    var scrollToActiveItem = this.props.scrollToActiveItem !== false;\n    var externalChangeToActiveItem = !executeItemsEqual(this.props.itemsEqual, getActiveItem(this.expectedNextActiveItem), getActiveItem(this.props.activeItem));\n    this.expectedNextActiveItem = null;\n\n    if (!scrollToActiveItem && externalChangeToActiveItem) {\n      return;\n    }\n\n    var activeElement = this.getActiveElement();\n\n    if (this.itemsParentRef != null && activeElement != null) {\n      var activeTop = activeElement.offsetTop,\n          activeHeight = activeElement.offsetHeight;\n      var _a = this.itemsParentRef,\n          parentOffsetTop = _a.offsetTop,\n          parentScrollTop = _a.scrollTop,\n          parentHeight = _a.clientHeight; // compute padding on parent element to ensure we always leave space\n\n      var _b = this.getItemsParentPadding(),\n          paddingTop = _b.paddingTop,\n          paddingBottom = _b.paddingBottom; // compute the two edges of the active item for comparison, including parent padding\n\n\n      var activeBottomEdge = activeTop + activeHeight + paddingBottom - parentOffsetTop;\n      var activeTopEdge = activeTop - paddingTop - parentOffsetTop;\n\n      if (activeBottomEdge >= parentScrollTop + parentHeight) {\n        // offscreen bottom: align bottom of item with bottom of viewport\n        this.itemsParentRef.scrollTop = activeBottomEdge + activeHeight - parentHeight;\n      } else if (activeTopEdge <= parentScrollTop) {\n        // offscreen top: align top of item with top of viewport\n        this.itemsParentRef.scrollTop = activeTopEdge - activeHeight;\n      }\n    }\n  };\n\n  QueryList.prototype.setQuery = function (query, resetActiveItem, props) {\n    if (resetActiveItem === void 0) {\n      resetActiveItem = this.props.resetOnQuery;\n    }\n\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    var createNewItemFromQuery = props.createNewItemFromQuery;\n    this.shouldCheckActiveItemInViewport = true;\n    var hasQueryChanged = query !== this.state.query;\n\n    if (hasQueryChanged) {\n      Utils.safeInvoke(props.onQueryChange, query);\n    }\n\n    var filteredItems = getFilteredItems(query, props);\n    var createNewItem = createNewItemFromQuery != null && query !== \"\" ? createNewItemFromQuery(query) : undefined;\n    this.setState({\n      createNewItem: createNewItem,\n      filteredItems: filteredItems,\n      query: query\n    }); // always reset active item if it's now filtered or disabled\n\n    var activeIndex = this.getActiveIndex(filteredItems);\n    var shouldUpdateActiveItem = resetActiveItem || activeIndex < 0 || isItemDisabled(getActiveItem(this.state.activeItem), activeIndex, props.itemDisabled);\n\n    if (shouldUpdateActiveItem) {\n      this.setActiveItem(getFirstEnabledItem(filteredItems, props.itemDisabled));\n    }\n  };\n\n  QueryList.prototype.getActiveElement = function () {\n    var activeItem = this.state.activeItem;\n\n    if (this.itemsParentRef != null) {\n      if (isCreateNewItem(activeItem)) {\n        return this.itemsParentRef.children.item(this.state.filteredItems.length);\n      } else {\n        var activeIndex = this.getActiveIndex();\n        return this.itemsParentRef.children.item(activeIndex);\n      }\n    }\n\n    return undefined;\n  };\n\n  QueryList.prototype.getActiveIndex = function (items) {\n    if (items === void 0) {\n      items = this.state.filteredItems;\n    }\n\n    var activeItem = this.state.activeItem;\n\n    if (activeItem == null || isCreateNewItem(activeItem)) {\n      return -1;\n    } // NOTE: this operation is O(n) so it should be avoided in render(). safe for events though.\n\n\n    for (var i = 0; i < items.length; ++i) {\n      if (executeItemsEqual(this.props.itemsEqual, items[i], activeItem)) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  QueryList.prototype.getItemsParentPadding = function () {\n    // assert ref exists because it was checked before calling\n    var _a = getComputedStyle(this.itemsParentRef),\n        paddingTop = _a.paddingTop,\n        paddingBottom = _a.paddingBottom;\n\n    return {\n      paddingBottom: pxToNumber(paddingBottom),\n      paddingTop: pxToNumber(paddingTop)\n    };\n  };\n  /**\n   * Get the next enabled item, moving in the given direction from the start\n   * index. A `null` return value means no suitable item was found.\n   * @param direction amount to move in each iteration, typically +/-1\n   * @param startIndex item to start iteration\n   */\n\n\n  QueryList.prototype.getNextActiveItem = function (direction, startIndex) {\n    if (startIndex === void 0) {\n      startIndex = this.getActiveIndex();\n    }\n\n    if (this.isCreateItemRendered()) {\n      var reachedCreate = startIndex === 0 && direction === -1 || startIndex === this.state.filteredItems.length - 1 && direction === 1;\n\n      if (reachedCreate) {\n        return getCreateNewItem();\n      }\n    }\n\n    return getFirstEnabledItem(this.state.filteredItems, this.props.itemDisabled, direction, startIndex);\n  };\n\n  QueryList.prototype.setActiveItem = function (activeItem) {\n    this.expectedNextActiveItem = activeItem;\n\n    if (this.props.activeItem === undefined) {\n      // indicate that the active item may need to be scrolled into view after update.\n      this.shouldCheckActiveItemInViewport = true;\n      this.setState({\n        activeItem: activeItem\n      });\n    }\n\n    if (isCreateNewItem(activeItem)) {\n      Utils.safeInvoke(this.props.onActiveItemChange, null, true);\n    } else {\n      Utils.safeInvoke(this.props.onActiveItemChange, activeItem, false);\n    }\n  };\n\n  QueryList.prototype.isCreateItemRendered = function () {\n    return this.canCreateItems() && this.state.query !== \"\" && // this check is unfortunately O(N) on the number of items, but\n    // alas, hiding the \"Create Item\" option when it exactly matches an\n    // existing item is much clearer.\n    !this.wouldCreatedItemMatchSomeExistingItem();\n  };\n\n  QueryList.prototype.canCreateItems = function () {\n    return this.props.createNewItemFromQuery != null && this.props.createNewItemRenderer != null;\n  };\n\n  QueryList.prototype.wouldCreatedItemMatchSomeExistingItem = function () {\n    var _this = this; // search only the filtered items, not the full items list, because we\n    // only need to check items that match the current query.\n\n\n    return this.state.filteredItems.some(function (item) {\n      return executeItemsEqual(_this.props.itemsEqual, item, _this.state.createNewItem);\n    });\n  };\n\n  QueryList.displayName = DISPLAYNAME_PREFIX + \".QueryList\";\n  QueryList.defaultProps = {\n    disabled: false,\n    resetOnQuery: true\n  };\n  return QueryList;\n}(AbstractComponent2);\n\nexport { QueryList };\n\nfunction pxToNumber(value) {\n  return value == null ? 0 : parseInt(value.slice(0, -2), 10);\n}\n\nfunction getMatchingItem(query, _a) {\n  var items = _a.items,\n      itemPredicate = _a.itemPredicate;\n\n  if (Utils.isFunction(itemPredicate)) {\n    // .find() doesn't exist in ES5. Alternative: use a for loop instead of\n    // .filter() so that we can return as soon as we find the first match.\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (itemPredicate(query, item, i, true)) {\n        return item;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction getFilteredItems(query, _a) {\n  var items = _a.items,\n      itemPredicate = _a.itemPredicate,\n      itemListPredicate = _a.itemListPredicate;\n\n  if (Utils.isFunction(itemListPredicate)) {\n    // note that implementations can reorder the items here\n    return itemListPredicate(query, items);\n  } else if (Utils.isFunction(itemPredicate)) {\n    return items.filter(function (item, index) {\n      return itemPredicate(query, item, index);\n    });\n  }\n\n  return items;\n}\n/** Wrap number around min/max values: if it exceeds one bound, return the other. */\n\n\nfunction wrapNumber(value, min, max) {\n  if (value < min) {\n    return max;\n  } else if (value > max) {\n    return min;\n  }\n\n  return value;\n}\n\nfunction isItemDisabled(item, index, itemDisabled) {\n  if (itemDisabled == null || item == null) {\n    return false;\n  } else if (Utils.isFunction(itemDisabled)) {\n    return itemDisabled(item, index);\n  }\n\n  return !!item[itemDisabled];\n}\n/**\n * Get the next enabled item, moving in the given direction from the start\n * index. A `null` return value means no suitable item was found.\n * @param items the list of items\n * @param itemDisabled callback to determine if a given item is disabled\n * @param direction amount to move in each iteration, typically +/-1\n * @param startIndex which index to begin moving from\n */\n\n\nexport function getFirstEnabledItem(items, itemDisabled, direction, startIndex) {\n  if (direction === void 0) {\n    direction = 1;\n  }\n\n  if (startIndex === void 0) {\n    startIndex = items.length - 1;\n  }\n\n  if (items.length === 0) {\n    return null;\n  } // remember where we started to prevent an infinite loop\n\n\n  var index = startIndex;\n  var maxIndex = items.length - 1;\n\n  do {\n    // find first non-disabled item\n    index = wrapNumber(index + direction, 0, maxIndex);\n\n    if (!isItemDisabled(items[index], index, itemDisabled)) {\n      return items[index];\n    }\n  } while (index !== startIndex && startIndex !== -1);\n\n  return null;\n}","map":null,"metadata":{},"sourceType":"module"}