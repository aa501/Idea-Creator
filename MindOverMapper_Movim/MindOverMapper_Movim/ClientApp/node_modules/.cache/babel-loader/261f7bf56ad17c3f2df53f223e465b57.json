{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { AbstractComponent2, DISPLAYNAME_PREFIX, Keys, Menu, Utils } from \"@blueprintjs/core\";\nimport { executeItemsEqual, getActiveItem, getCreateNewItem, isCreateNewItem, renderFilteredItems } from \"../../common\";\n\nvar QueryList =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(QueryList, _super);\n\n  function QueryList(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.refHandlers = {\n      itemsParent: function (ref) {\n        return _this.itemsParentRef = ref;\n      }\n    };\n    /**\n     * Flag indicating that we should check whether selected item is in viewport\n     * after rendering, typically because of keyboard change. Set to `true` when\n     * manipulating state in a way that may cause active item to scroll away.\n     */\n\n    _this.shouldCheckActiveItemInViewport = false;\n    /**\n     * The item that we expect to be the next selected active item (based on click\n     * or key interactions). When scrollToActiveItem = false, used to detect if\n     * an unexpected external change to the active item has been made.\n     */\n\n    _this.expectedNextActiveItem = null;\n    /** default `itemListRenderer` implementation */\n\n    _this.renderItemList = function (listProps) {\n      var _a = _this.props,\n          initialContent = _a.initialContent,\n          noResults = _a.noResults; // omit noResults if createNewItemFromQuery and createNewItemRenderer are both supplied, and query is not empty\n\n      var maybeNoResults = _this.isCreateItemRendered() ? null : noResults;\n      var menuContent = renderFilteredItems(listProps, maybeNoResults, initialContent);\n      var createItemView = _this.isCreateItemRendered() ? _this.renderCreateItemMenuItem(_this.state.query) : null;\n\n      if (menuContent == null && createItemView == null) {\n        return null;\n      }\n\n      return React.createElement(Menu, {\n        ulRef: listProps.itemsParentRef\n      }, menuContent, createItemView);\n    };\n    /** wrapper around `itemRenderer` to inject props */\n\n\n    _this.renderItem = function (item, index) {\n      if (_this.props.disabled !== true) {\n        var _a = _this.state,\n            activeItem = _a.activeItem,\n            query = _a.query;\n        var matchesPredicate = _this.state.filteredItems.indexOf(item) >= 0;\n        var modifiers = {\n          active: executeItemsEqual(_this.props.itemsEqual, getActiveItem(activeItem), item),\n          disabled: isItemDisabled(item, index, _this.props.itemDisabled),\n          matchesPredicate: matchesPredicate\n        };\n        return _this.props.itemRenderer(item, {\n          handleClick: function (e) {\n            return _this.handleItemSelect(item, e);\n          },\n          index: index,\n          modifiers: modifiers,\n          query: query\n        });\n      }\n\n      return null;\n    };\n\n    _this.renderCreateItemMenuItem = function (query) {\n      var activeItem = _this.state.activeItem;\n\n      var handleClick = function (evt) {\n        _this.handleItemCreate(query, evt);\n      };\n\n      var isActive = isCreateNewItem(activeItem);\n      return Utils.safeInvoke(_this.props.createNewItemRenderer, query, isActive, handleClick);\n    };\n\n    _this.handleItemCreate = function (query, evt) {\n      // we keep a cached createNewItem in state, but might as well recompute\n      // the result just to be sure it's perfectly in sync with the query.\n      var item = Utils.safeInvoke(_this.props.createNewItemFromQuery, query);\n\n      if (item != null) {\n        Utils.safeInvoke(_this.props.onItemSelect, item, evt);\n\n        _this.setQuery(\"\", true);\n      }\n    };\n\n    _this.handleItemSelect = function (item, event) {\n      _this.setActiveItem(item);\n\n      Utils.safeInvoke(_this.props.onItemSelect, item, event);\n\n      if (_this.props.resetOnSelect) {\n        _this.setQuery(\"\", true);\n      }\n    };\n\n    _this.handlePaste = function (queries) {\n      var _a = _this.props,\n          createNewItemFromQuery = _a.createNewItemFromQuery,\n          onItemsPaste = _a.onItemsPaste;\n      var nextActiveItem;\n      var nextQueries = []; // Find an exising item that exactly matches each pasted value, or\n      // create a new item if possible. Ignore unmatched values if creating\n      // items is disabled.\n\n      var pastedItemsToEmit = [];\n\n      for (var _i = 0, queries_1 = queries; _i < queries_1.length; _i++) {\n        var query = queries_1[_i];\n        var equalItem = getMatchingItem(query, _this.props);\n\n        if (equalItem !== undefined) {\n          nextActiveItem = equalItem;\n          pastedItemsToEmit.push(equalItem);\n        } else if (_this.canCreateItems()) {\n          var newItem = Utils.safeInvoke(createNewItemFromQuery, query);\n\n          if (newItem !== undefined) {\n            pastedItemsToEmit.push(newItem);\n          }\n        } else {\n          nextQueries.push(query);\n        }\n      } // UX nicety: combine all unmatched queries into a single\n      // comma-separated query in the input, so we don't lose any information.\n      // And don't reset the active item; we'll do that ourselves below.\n\n\n      _this.setQuery(nextQueries.join(\", \"), false); // UX nicety: update the active item if we matched with at least one\n      // existing item.\n\n\n      if (nextActiveItem !== undefined) {\n        _this.setActiveItem(nextActiveItem);\n      }\n\n      Utils.safeInvoke(onItemsPaste, pastedItemsToEmit);\n    };\n\n    _this.handleKeyDown = function (event) {\n      var keyCode = event.keyCode;\n\n      if (keyCode === Keys.ARROW_UP || keyCode === Keys.ARROW_DOWN) {\n        event.preventDefault();\n\n        var nextActiveItem = _this.getNextActiveItem(keyCode === Keys.ARROW_UP ? -1 : 1);\n\n        if (nextActiveItem != null) {\n          _this.setActiveItem(nextActiveItem);\n        }\n      }\n\n      Utils.safeInvoke(_this.props.onKeyDown, event);\n    };\n\n    _this.handleKeyUp = function (event) {\n      var onKeyUp = _this.props.onKeyUp;\n      var activeItem = _this.state.activeItem; // using keyup for enter to play nice with Button's keyboard clicking.\n      // if we were to process enter on keydown, then Button would click itself on keyup\n      // and the popvoer would re-open out of our control :(.\n\n      if (event.keyCode === Keys.ENTER) {\n        event.preventDefault();\n\n        if (activeItem == null || isCreateNewItem(activeItem)) {\n          _this.handleItemCreate(_this.state.query, event);\n        } else {\n          _this.handleItemSelect(activeItem, event);\n        }\n      }\n\n      Utils.safeInvoke(onKeyUp, event);\n    };\n\n    _this.handleQueryChange = function (event) {\n      var query = event == null ? \"\" : event.target.value;\n\n      _this.setQuery(query);\n\n      Utils.safeInvoke(_this.props.onQueryChange, query, event);\n    };\n\n    var _a = props.query,\n        query = _a === void 0 ? \"\" : _a;\n    var createNewItem = Utils.safeInvoke(props.createNewItemFromQuery, query);\n    var filteredItems = getFilteredItems(query, props);\n    _this.state = {\n      activeItem: props.activeItem !== undefined ? props.activeItem : getFirstEnabledItem(filteredItems, props.itemDisabled),\n      createNewItem: createNewItem,\n      filteredItems: filteredItems,\n      query: query\n    };\n    return _this;\n  }\n\n  QueryList.ofType = function () {\n    return QueryList;\n  };\n\n  QueryList.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        items = _a.items,\n        renderer = _a.renderer,\n        _b = _a.itemListRenderer,\n        itemListRenderer = _b === void 0 ? this.renderItemList : _b;\n\n    var _c = this.state,\n        createNewItem = _c.createNewItem,\n        spreadableState = tslib_1.__rest(_c, [\"createNewItem\"]);\n\n    return renderer(tslib_1.__assign({}, spreadableState, {\n      className: className,\n      handleItemSelect: this.handleItemSelect,\n      handleKeyDown: this.handleKeyDown,\n      handleKeyUp: this.handleKeyUp,\n      handlePaste: this.handlePaste,\n      handleQueryChange: this.handleQueryChange,\n      itemList: itemListRenderer(tslib_1.__assign({}, spreadableState, {\n        items: items,\n        itemsParentRef: this.refHandlers.itemsParent,\n        renderItem: this.renderItem\n      }))\n    }));\n  };\n\n  QueryList.prototype.componentDidUpdate = function (prevProps) {\n    var _this = this;\n\n    if (this.props.activeItem !== undefined && this.props.activeItem !== this.state.activeItem) {\n      this.shouldCheckActiveItemInViewport = true;\n      this.setState({\n        activeItem: this.props.activeItem\n      });\n    }\n\n    if (this.props.query != null && this.props.query !== prevProps.query) {\n      // new query\n      this.setQuery(this.props.query, this.props.resetOnQuery, this.props);\n    } else if ( // same query (or uncontrolled query), but items in the list changed\n    !Utils.shallowCompareKeys(this.props, prevProps, {\n      include: [\"items\", \"itemListPredicate\", \"itemPredicate\"]\n    })) {\n      this.setQuery(this.state.query);\n    }\n\n    if (this.shouldCheckActiveItemInViewport) {\n      // update scroll position immediately before repaint so DOM is accurate\n      // (latest filteredItems) and to avoid flicker.\n      requestAnimationFrame(function () {\n        return _this.scrollActiveItemIntoView();\n      }); // reset the flag\n\n      this.shouldCheckActiveItemInViewport = false;\n    }\n  };\n\n  QueryList.prototype.scrollActiveItemIntoView = function () {\n    var scrollToActiveItem = this.props.scrollToActiveItem !== false;\n    var externalChangeToActiveItem = !executeItemsEqual(this.props.itemsEqual, getActiveItem(this.expectedNextActiveItem), getActiveItem(this.props.activeItem));\n    this.expectedNextActiveItem = null;\n\n    if (!scrollToActiveItem && externalChangeToActiveItem) {\n      return;\n    }\n\n    var activeElement = this.getActiveElement();\n\n    if (this.itemsParentRef != null && activeElement != null) {\n      var activeTop = activeElement.offsetTop,\n          activeHeight = activeElement.offsetHeight;\n      var _a = this.itemsParentRef,\n          parentOffsetTop = _a.offsetTop,\n          parentScrollTop = _a.scrollTop,\n          parentHeight = _a.clientHeight; // compute padding on parent element to ensure we always leave space\n\n      var _b = this.getItemsParentPadding(),\n          paddingTop = _b.paddingTop,\n          paddingBottom = _b.paddingBottom; // compute the two edges of the active item for comparison, including parent padding\n\n\n      var activeBottomEdge = activeTop + activeHeight + paddingBottom - parentOffsetTop;\n      var activeTopEdge = activeTop - paddingTop - parentOffsetTop;\n\n      if (activeBottomEdge >= parentScrollTop + parentHeight) {\n        // offscreen bottom: align bottom of item with bottom of viewport\n        this.itemsParentRef.scrollTop = activeBottomEdge + activeHeight - parentHeight;\n      } else if (activeTopEdge <= parentScrollTop) {\n        // offscreen top: align top of item with top of viewport\n        this.itemsParentRef.scrollTop = activeTopEdge - activeHeight;\n      }\n    }\n  };\n\n  QueryList.prototype.setQuery = function (query, resetActiveItem, props) {\n    if (resetActiveItem === void 0) {\n      resetActiveItem = this.props.resetOnQuery;\n    }\n\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    var createNewItemFromQuery = props.createNewItemFromQuery;\n    this.shouldCheckActiveItemInViewport = true;\n    var hasQueryChanged = query !== this.state.query;\n\n    if (hasQueryChanged) {\n      Utils.safeInvoke(props.onQueryChange, query);\n    }\n\n    var filteredItems = getFilteredItems(query, props);\n    var createNewItem = createNewItemFromQuery != null && query !== \"\" ? createNewItemFromQuery(query) : undefined;\n    this.setState({\n      createNewItem: createNewItem,\n      filteredItems: filteredItems,\n      query: query\n    }); // always reset active item if it's now filtered or disabled\n\n    var activeIndex = this.getActiveIndex(filteredItems);\n    var shouldUpdateActiveItem = resetActiveItem || activeIndex < 0 || isItemDisabled(getActiveItem(this.state.activeItem), activeIndex, props.itemDisabled);\n\n    if (shouldUpdateActiveItem) {\n      this.setActiveItem(getFirstEnabledItem(filteredItems, props.itemDisabled));\n    }\n  };\n\n  QueryList.prototype.getActiveElement = function () {\n    var activeItem = this.state.activeItem;\n\n    if (this.itemsParentRef != null) {\n      if (isCreateNewItem(activeItem)) {\n        return this.itemsParentRef.children.item(this.state.filteredItems.length);\n      } else {\n        var activeIndex = this.getActiveIndex();\n        return this.itemsParentRef.children.item(activeIndex);\n      }\n    }\n\n    return undefined;\n  };\n\n  QueryList.prototype.getActiveIndex = function (items) {\n    if (items === void 0) {\n      items = this.state.filteredItems;\n    }\n\n    var activeItem = this.state.activeItem;\n\n    if (activeItem == null || isCreateNewItem(activeItem)) {\n      return -1;\n    } // NOTE: this operation is O(n) so it should be avoided in render(). safe for events though.\n\n\n    for (var i = 0; i < items.length; ++i) {\n      if (executeItemsEqual(this.props.itemsEqual, items[i], activeItem)) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  QueryList.prototype.getItemsParentPadding = function () {\n    // assert ref exists because it was checked before calling\n    var _a = getComputedStyle(this.itemsParentRef),\n        paddingTop = _a.paddingTop,\n        paddingBottom = _a.paddingBottom;\n\n    return {\n      paddingBottom: pxToNumber(paddingBottom),\n      paddingTop: pxToNumber(paddingTop)\n    };\n  };\n  /**\n   * Get the next enabled item, moving in the given direction from the start\n   * index. A `null` return value means no suitable item was found.\n   * @param direction amount to move in each iteration, typically +/-1\n   * @param startIndex item to start iteration\n   */\n\n\n  QueryList.prototype.getNextActiveItem = function (direction, startIndex) {\n    if (startIndex === void 0) {\n      startIndex = this.getActiveIndex();\n    }\n\n    if (this.isCreateItemRendered()) {\n      var reachedCreate = startIndex === 0 && direction === -1 || startIndex === this.state.filteredItems.length - 1 && direction === 1;\n\n      if (reachedCreate) {\n        return getCreateNewItem();\n      }\n    }\n\n    return getFirstEnabledItem(this.state.filteredItems, this.props.itemDisabled, direction, startIndex);\n  };\n\n  QueryList.prototype.setActiveItem = function (activeItem) {\n    this.expectedNextActiveItem = activeItem;\n\n    if (this.props.activeItem === undefined) {\n      // indicate that the active item may need to be scrolled into view after update.\n      this.shouldCheckActiveItemInViewport = true;\n      this.setState({\n        activeItem: activeItem\n      });\n    }\n\n    if (isCreateNewItem(activeItem)) {\n      Utils.safeInvoke(this.props.onActiveItemChange, null, true);\n    } else {\n      Utils.safeInvoke(this.props.onActiveItemChange, activeItem, false);\n    }\n  };\n\n  QueryList.prototype.isCreateItemRendered = function () {\n    return this.canCreateItems() && this.state.query !== \"\" && // this check is unfortunately O(N) on the number of items, but\n    // alas, hiding the \"Create Item\" option when it exactly matches an\n    // existing item is much clearer.\n    !this.wouldCreatedItemMatchSomeExistingItem();\n  };\n\n  QueryList.prototype.canCreateItems = function () {\n    return this.props.createNewItemFromQuery != null && this.props.createNewItemRenderer != null;\n  };\n\n  QueryList.prototype.wouldCreatedItemMatchSomeExistingItem = function () {\n    var _this = this; // search only the filtered items, not the full items list, because we\n    // only need to check items that match the current query.\n\n\n    return this.state.filteredItems.some(function (item) {\n      return executeItemsEqual(_this.props.itemsEqual, item, _this.state.createNewItem);\n    });\n  };\n\n  QueryList.displayName = DISPLAYNAME_PREFIX + \".QueryList\";\n  QueryList.defaultProps = {\n    disabled: false,\n    resetOnQuery: true\n  };\n  return QueryList;\n}(AbstractComponent2);\n\nexport { QueryList };\n\nfunction pxToNumber(value) {\n  return value == null ? 0 : parseInt(value.slice(0, -2), 10);\n}\n\nfunction getMatchingItem(query, _a) {\n  var items = _a.items,\n      itemPredicate = _a.itemPredicate;\n\n  if (Utils.isFunction(itemPredicate)) {\n    // .find() doesn't exist in ES5. Alternative: use a for loop instead of\n    // .filter() so that we can return as soon as we find the first match.\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (itemPredicate(query, item, i, true)) {\n        return item;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction getFilteredItems(query, _a) {\n  var items = _a.items,\n      itemPredicate = _a.itemPredicate,\n      itemListPredicate = _a.itemListPredicate;\n\n  if (Utils.isFunction(itemListPredicate)) {\n    // note that implementations can reorder the items here\n    return itemListPredicate(query, items);\n  } else if (Utils.isFunction(itemPredicate)) {\n    return items.filter(function (item, index) {\n      return itemPredicate(query, item, index);\n    });\n  }\n\n  return items;\n}\n/** Wrap number around min/max values: if it exceeds one bound, return the other. */\n\n\nfunction wrapNumber(value, min, max) {\n  if (value < min) {\n    return max;\n  } else if (value > max) {\n    return min;\n  }\n\n  return value;\n}\n\nfunction isItemDisabled(item, index, itemDisabled) {\n  if (itemDisabled == null || item == null) {\n    return false;\n  } else if (Utils.isFunction(itemDisabled)) {\n    return itemDisabled(item, index);\n  }\n\n  return !!item[itemDisabled];\n}\n/**\n * Get the next enabled item, moving in the given direction from the start\n * index. A `null` return value means no suitable item was found.\n * @param items the list of items\n * @param itemDisabled callback to determine if a given item is disabled\n * @param direction amount to move in each iteration, typically +/-1\n * @param startIndex which index to begin moving from\n */\n\n\nexport function getFirstEnabledItem(items, itemDisabled, direction, startIndex) {\n  if (direction === void 0) {\n    direction = 1;\n  }\n\n  if (startIndex === void 0) {\n    startIndex = items.length - 1;\n  }\n\n  if (items.length === 0) {\n    return null;\n  } // remember where we started to prevent an infinite loop\n\n\n  var index = startIndex;\n  var maxIndex = items.length - 1;\n\n  do {\n    // find first non-disabled item\n    index = wrapNumber(index + direction, 0, maxIndex);\n\n    if (!isItemDisabled(items[index], index, itemDisabled)) {\n      return items[index];\n    }\n  } while (index !== startIndex && startIndex !== -1);\n\n  return null;\n}","map":{"version":3,"sources":["../../../../src/components/query-list/queryList.tsx"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AAEA,SAAS,kBAAT,EAA6B,kBAA7B,EAAyD,IAAzD,EAA+D,IAA/D,EAAqE,KAArE,QAAkF,mBAAlF;AACA,SACI,iBADJ,EAEI,aAFJ,EAGI,gBAHJ,EAQI,eARJ,EASI,mBATJ,QAUO,cAVP;;AAgHA,IAAA,SAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAkC,EAAA,OAAA,CAAA,SAAA,CAAA,SAAA,EAAA,MAAA;;AA+B9B,WAAA,SAAA,CAAmB,KAAnB,EAA8C,OAA9C,EAA2D;AAA3D,QAAA,KAAA,GACI,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,EAAa,OAAb,KAAqB,IADzB;;AAlBQ,IAAA,KAAA,CAAA,WAAA,GAAc;AAClB,MAAA,WAAW,EAAE,UAAC,GAAD,EAAwB;AAAK,eAAC,KAAI,CAAC,cAAL,GAAD,GAAA;AAA2B;AADnD,KAAd;AAIR;;;;;;AAKQ,IAAA,KAAA,CAAA,+BAAA,GAAkC,KAAlC;AAER;;;;;;AAKQ,IAAA,KAAA,CAAA,sBAAA,GAAoD,IAApD;AAmIR;;AACQ,IAAA,KAAA,CAAA,cAAA,GAAiB,UAAC,SAAD,EAAqC;AACpD,UAAA,EAAA,GAAA,KAAA,CAAA,KAAA;AAAA,UAAE,cAAA,GAAA,EAAA,CAAA,cAAF;AAAA,UAAkB,SAAA,GAAA,EAAA,CAAA,SAAlB,CADoD,CAG1D;;AACA,UAAM,cAAc,GAAG,KAAI,CAAC,oBAAL,KAA8B,IAA9B,GAAqC,SAA5D;AACA,UAAM,WAAW,GAAG,mBAAmB,CAAC,SAAD,EAAY,cAAZ,EAA4B,cAA5B,CAAvC;AACA,UAAM,cAAc,GAAG,KAAI,CAAC,oBAAL,KAA8B,KAAI,CAAC,wBAAL,CAA8B,KAAI,CAAC,KAAL,CAAW,KAAzC,CAA9B,GAAgF,IAAvG;;AACA,UAAI,WAAW,IAAI,IAAf,IAAuB,cAAc,IAAI,IAA7C,EAAmD;AAC/C,eAAO,IAAP;AACH;;AACD,aACI,KAAA,CAAA,aAAA,CAAC,IAAD,EAAK;AAAC,QAAA,KAAK,EAAE,SAAS,CAAC;AAAlB,OAAL,EACK,WADL,EAEK,cAFL,CADJ;AAMH,KAhBO;AAkBR;;;AACQ,IAAA,KAAA,CAAA,UAAA,GAAa,UAAC,IAAD,EAAU,KAAV,EAAuB;AACxC,UAAI,KAAI,CAAC,KAAL,CAAW,QAAX,KAAwB,IAA5B,EAAkC;AACxB,YAAA,EAAA,GAAA,KAAA,CAAA,KAAA;AAAA,YAAE,UAAA,GAAA,EAAA,CAAA,UAAF;AAAA,YAAc,KAAA,GAAA,EAAA,CAAA,KAAd;AACN,YAAM,gBAAgB,GAAG,KAAI,CAAC,KAAL,CAAW,aAAX,CAAyB,OAAzB,CAAiC,IAAjC,KAA0C,CAAnE;AACA,YAAM,SAAS,GAAmB;AAC9B,UAAA,MAAM,EAAE,iBAAiB,CAAC,KAAI,CAAC,KAAL,CAAW,UAAZ,EAAwB,aAAa,CAAC,UAAD,CAArC,EAAmD,IAAnD,CADK;AAE9B,UAAA,QAAQ,EAAE,cAAc,CAAC,IAAD,EAAO,KAAP,EAAc,KAAI,CAAC,KAAL,CAAW,YAAzB,CAFM;AAG9B,UAAA,gBAAgB,EAAA;AAHc,SAAlC;AAKA,eAAO,KAAI,CAAC,KAAL,CAAW,YAAX,CAAwB,IAAxB,EAA8B;AACjC,UAAA,WAAW,EAAE,UAAA,CAAA,EAAC;AAAI,mBAAA,KAAI,CAAC,gBAAL,CAAsB,IAAtB,EAAA,CAAA,CAAA;AAA8B,WADf;AAEjC,UAAA,KAAK,EAAA,KAF4B;AAGjC,UAAA,SAAS,EAAA,SAHwB;AAIjC,UAAA,KAAK,EAAA;AAJ4B,SAA9B,CAAP;AAMH;;AAED,aAAO,IAAP;AACH,KAlBO;;AAoBA,IAAA,KAAA,CAAA,wBAAA,GAA2B,UAAC,KAAD,EAAc;AACrC,UAAA,UAAA,GAAA,KAAA,CAAA,KAAA,CAAA,UAAA;;AACR,UAAM,WAAW,GAAyC,UAAA,GAAA,EAAG;AACzD,QAAA,KAAI,CAAC,gBAAL,CAAsB,KAAtB,EAA6B,GAA7B;AACH,OAFD;;AAGA,UAAM,QAAQ,GAAG,eAAe,CAAC,UAAD,CAAhC;AACA,aAAO,KAAK,CAAC,UAAN,CAAiB,KAAI,CAAC,KAAL,CAAW,qBAA5B,EAAmD,KAAnD,EAA0D,QAA1D,EAAoE,WAApE,CAAP;AACH,KAPO;;AA6CA,IAAA,KAAA,CAAA,gBAAA,GAAmB,UAAC,KAAD,EAAgB,GAAhB,EAAuD;AAC9E;AACA;AACA,UAAM,IAAI,GAAG,KAAK,CAAC,UAAN,CAAiB,KAAI,CAAC,KAAL,CAAW,sBAA5B,EAAoD,KAApD,CAAb;;AACA,UAAI,IAAI,IAAI,IAAZ,EAAkB;AACd,QAAA,KAAK,CAAC,UAAN,CAAiB,KAAI,CAAC,KAAL,CAAW,YAA5B,EAA0C,IAA1C,EAAgD,GAAhD;;AACA,QAAA,KAAI,CAAC,QAAL,CAAc,EAAd,EAAkB,IAAlB;AACH;AACJ,KARO;;AAUA,IAAA,KAAA,CAAA,gBAAA,GAAmB,UAAC,IAAD,EAAU,KAAV,EAAmD;AAC1E,MAAA,KAAI,CAAC,aAAL,CAAmB,IAAnB;;AACA,MAAA,KAAK,CAAC,UAAN,CAAiB,KAAI,CAAC,KAAL,CAAW,YAA5B,EAA0C,IAA1C,EAAgD,KAAhD;;AACA,UAAI,KAAI,CAAC,KAAL,CAAW,aAAf,EAA8B;AAC1B,QAAA,KAAI,CAAC,QAAL,CAAc,EAAd,EAAkB,IAAlB;AACH;AACJ,KANO;;AAQA,IAAA,KAAA,CAAA,WAAA,GAAc,UAAC,OAAD,EAAkB;AAC9B,UAAA,EAAA,GAAA,KAAA,CAAA,KAAA;AAAA,UAAE,sBAAA,GAAA,EAAA,CAAA,sBAAF;AAAA,UAA0B,YAAA,GAAA,EAAA,CAAA,YAA1B;AAEN,UAAI,cAAJ;AACA,UAAM,WAAW,GAAG,EAApB,CAJoC,CAMpC;AACA;AACA;;AACA,UAAM,iBAAiB,GAAG,EAA1B;;AAEA,WAAoB,IAAA,EAAA,GAAA,CAAA,EAAA,SAAA,GAAA,OAApB,EAAoB,EAAA,GAAA,SAAA,CAAA,MAApB,EAAoB,EAAA,EAApB,EAA6B;AAAxB,YAAM,KAAK,GAAA,SAAA,CAAA,EAAA,CAAX;AACD,YAAM,SAAS,GAAG,eAAe,CAAC,KAAD,EAAQ,KAAI,CAAC,KAAb,CAAjC;;AAEA,YAAI,SAAS,KAAK,SAAlB,EAA6B;AACzB,UAAA,cAAc,GAAG,SAAjB;AACA,UAAA,iBAAiB,CAAC,IAAlB,CAAuB,SAAvB;AACH,SAHD,MAGO,IAAI,KAAI,CAAC,cAAL,EAAJ,EAA2B;AAC9B,cAAM,OAAO,GAAG,KAAK,CAAC,UAAN,CAAiB,sBAAjB,EAAyC,KAAzC,CAAhB;;AACA,cAAI,OAAO,KAAK,SAAhB,EAA2B;AACvB,YAAA,iBAAiB,CAAC,IAAlB,CAAuB,OAAvB;AACH;AACJ,SALM,MAKA;AACH,UAAA,WAAW,CAAC,IAAZ,CAAiB,KAAjB;AACH;AACJ,OAzBmC,CA2BpC;AACA;AACA;;;AACA,MAAA,KAAI,CAAC,QAAL,CAAc,WAAW,CAAC,IAAZ,CAAiB,IAAjB,CAAd,EAAsC,KAAtC,EA9BoC,CAgCpC;AACA;;;AACA,UAAI,cAAc,KAAK,SAAvB,EAAkC;AAC9B,QAAA,KAAI,CAAC,aAAL,CAAmB,cAAnB;AACH;;AAED,MAAA,KAAK,CAAC,UAAN,CAAiB,YAAjB,EAA+B,iBAA/B;AACH,KAvCO;;AAyCA,IAAA,KAAA,CAAA,aAAA,GAAgB,UAAC,KAAD,EAAwC;AACpD,UAAA,OAAA,GAAA,KAAA,CAAA,OAAA;;AACR,UAAI,OAAO,KAAK,IAAI,CAAC,QAAjB,IAA6B,OAAO,KAAK,IAAI,CAAC,UAAlD,EAA8D;AAC1D,QAAA,KAAK,CAAC,cAAN;;AACA,YAAM,cAAc,GAAG,KAAI,CAAC,iBAAL,CAAuB,OAAO,KAAK,IAAI,CAAC,QAAjB,GAA4B,CAAC,CAA7B,GAAiC,CAAxD,CAAvB;;AACA,YAAI,cAAc,IAAI,IAAtB,EAA4B;AACxB,UAAA,KAAI,CAAC,aAAL,CAAmB,cAAnB;AACH;AACJ;;AACD,MAAA,KAAK,CAAC,UAAN,CAAiB,KAAI,CAAC,KAAL,CAAW,SAA5B,EAAuC,KAAvC;AACH,KAVO;;AAYA,IAAA,KAAA,CAAA,WAAA,GAAc,UAAC,KAAD,EAAwC;AAClD,UAAA,OAAA,GAAA,KAAA,CAAA,KAAA,CAAA,OAAA;AACA,UAAA,UAAA,GAAA,KAAA,CAAA,KAAA,CAAA,UAAA,CAFkD,CAG1D;AACA;AACA;;AACA,UAAI,KAAK,CAAC,OAAN,KAAkB,IAAI,CAAC,KAA3B,EAAkC;AAC9B,QAAA,KAAK,CAAC,cAAN;;AACA,YAAI,UAAU,IAAI,IAAd,IAAsB,eAAe,CAAC,UAAD,CAAzC,EAAuD;AACnD,UAAA,KAAI,CAAC,gBAAL,CAAsB,KAAI,CAAC,KAAL,CAAW,KAAjC,EAAwC,KAAxC;AACH,SAFD,MAEO;AACH,UAAA,KAAI,CAAC,gBAAL,CAAsB,UAAtB,EAAkC,KAAlC;AACH;AACJ;;AACD,MAAA,KAAK,CAAC,UAAN,CAAiB,OAAjB,EAA0B,KAA1B;AACH,KAfO;;AAiBA,IAAA,KAAA,CAAA,iBAAA,GAAoB,UAAC,KAAD,EAA4C;AACpE,UAAM,KAAK,GAAG,KAAK,IAAI,IAAT,GAAgB,EAAhB,GAAqB,KAAK,CAAC,MAAN,CAAa,KAAhD;;AACA,MAAA,KAAI,CAAC,QAAL,CAAc,KAAd;;AACA,MAAA,KAAK,CAAC,UAAN,CAAiB,KAAI,CAAC,KAAL,CAAW,aAA5B,EAA2C,KAA3C,EAAkD,KAAlD;AACH,KAJO;;AA3SI,QAAA,EAAA,GAAA,KAAA,CAAA,KAAA;AAAA,QAAA,KAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,EAAA;AACR,QAAM,aAAa,GAAG,KAAK,CAAC,UAAN,CAAiB,KAAK,CAAC,sBAAvB,EAA+C,KAA/C,CAAtB;AACA,QAAM,aAAa,GAAG,gBAAgB,CAAC,KAAD,EAAQ,KAAR,CAAtC;AAEA,IAAA,KAAI,CAAC,KAAL,GAAa;AACT,MAAA,UAAU,EACN,KAAK,CAAC,UAAN,KAAqB,SAArB,GACM,KAAK,CAAC,UADZ,GAEM,mBAAmB,CAAC,aAAD,EAAgB,KAAK,CAAC,YAAtB,CAJpB;AAKT,MAAA,aAAa,EAAA,aALJ;AAMT,MAAA,aAAa,EAAA,aANJ;AAOT,MAAA,KAAK,EAAA;AAPI,KAAb;;AASH;;AAvCa,EAAA,SAAA,CAAA,MAAA,GAAd,YAAA;AACI,WAAO,SAAP;AACH,GAFa;;AAyCP,EAAA,SAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;AACU,QAAA,EAAA,GAAA,KAAA,KAAA;AAAA,QAAE,SAAA,GAAA,EAAA,CAAA,SAAF;AAAA,QAAa,KAAA,GAAA,EAAA,CAAA,KAAb;AAAA,QAAoB,QAAA,GAAA,EAAA,CAAA,QAApB;AAAA,QAA8B,EAAA,GAAA,EAAA,CAAA,gBAA9B;AAAA,QAA8B,gBAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,cAAA,GAAA,EAA9B;;AACN,QAAM,EAAA,GAAA,KAAA,KAAN;AAAA,QAAQ,aAAA,GAAA,EAAA,CAAA,aAAR;AAAA,QAAuB,eAAA,GAAA,OAAA,CAAA,MAAA,CAAA,EAAA,EAAA,CAAA,eAAA,CAAA,CAAvB;;AACA,WAAO,QAAQ,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EACR,eADQ,EACO;AAClB,MAAA,SAAS,EAAA,SADS;AAElB,MAAA,gBAAgB,EAAE,KAAK,gBAFL;AAGlB,MAAA,aAAa,EAAE,KAAK,aAHF;AAIlB,MAAA,WAAW,EAAE,KAAK,WAJA;AAKlB,MAAA,WAAW,EAAE,KAAK,WALA;AAMlB,MAAA,iBAAiB,EAAE,KAAK,iBANN;AAOlB,MAAA,QAAQ,EAAE,gBAAgB,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EACnB,eADmB,EACJ;AAClB,QAAA,KAAK,EAAA,KADa;AAElB,QAAA,cAAc,EAAE,KAAK,WAAL,CAAiB,WAFf;AAGlB,QAAA,UAAU,EAAE,KAAK;AAHC,OADI,CAAA;AAPR,KADP,CAAA,CAAf;AAeH,GAlBM;;AAoBA,EAAA,SAAA,CAAA,SAAA,CAAA,kBAAA,GAAP,UAA0B,SAA1B,EAAuD;AAAvD,QAAA,KAAA,GAAA,IAAA;;AACI,QAAI,KAAK,KAAL,CAAW,UAAX,KAA0B,SAA1B,IAAuC,KAAK,KAAL,CAAW,UAAX,KAA0B,KAAK,KAAL,CAAW,UAAhF,EAA4F;AACxF,WAAK,+BAAL,GAAuC,IAAvC;AACA,WAAK,QAAL,CAAc;AAAE,QAAA,UAAU,EAAE,KAAK,KAAL,CAAW;AAAzB,OAAd;AACH;;AAED,QAAI,KAAK,KAAL,CAAW,KAAX,IAAoB,IAApB,IAA4B,KAAK,KAAL,CAAW,KAAX,KAAqB,SAAS,CAAC,KAA/D,EAAsE;AAClE;AACA,WAAK,QAAL,CAAc,KAAK,KAAL,CAAW,KAAzB,EAAgC,KAAK,KAAL,CAAW,YAA3C,EAAyD,KAAK,KAA9D;AACH,KAHD,MAGO,KACH;AACA,KAAC,KAAK,CAAC,kBAAN,CAAyB,KAAK,KAA9B,EAAqC,SAArC,EAAgD;AAC7C,MAAA,OAAO,EAAE,CAAC,OAAD,EAAU,mBAAV,EAA+B,eAA/B;AADoC,KAAhD,CAFE,EAKL;AACE,WAAK,QAAL,CAAc,KAAK,KAAL,CAAW,KAAzB;AACH;;AAED,QAAI,KAAK,+BAAT,EAA0C;AACtC;AACA;AACA,MAAA,qBAAqB,CAAC,YAAA;AAAM,eAAA,KAAI,CAAJ,wBAAA,EAAA;AAA+B,OAAtC,CAArB,CAHsC,CAItC;;AACA,WAAK,+BAAL,GAAuC,KAAvC;AACH;AACJ,GAzBM;;AA2BA,EAAA,SAAA,CAAA,SAAA,CAAA,wBAAA,GAAP,YAAA;AACI,QAAM,kBAAkB,GAAG,KAAK,KAAL,CAAW,kBAAX,KAAkC,KAA7D;AACA,QAAM,0BAA0B,GAAG,CAAC,iBAAiB,CACjD,KAAK,KAAL,CAAW,UADsC,EAEjD,aAAa,CAAC,KAAK,sBAAN,CAFoC,EAGjD,aAAa,CAAC,KAAK,KAAL,CAAW,UAAZ,CAHoC,CAArD;AAKA,SAAK,sBAAL,GAA8B,IAA9B;;AAEA,QAAI,CAAC,kBAAD,IAAuB,0BAA3B,EAAuD;AACnD;AACH;;AAED,QAAM,aAAa,GAAG,KAAK,gBAAL,EAAtB;;AACA,QAAI,KAAK,cAAL,IAAuB,IAAvB,IAA+B,aAAa,IAAI,IAApD,EAA0D;AAC9C,UAAA,SAAA,GAAA,aAAA,CAAA,SAAA;AAAA,UAAsB,YAAA,GAAA,aAAA,CAAA,YAAtB;AACF,UAAA,EAAA,GAAA,KAAA,cAAA;AAAA,UACF,eAAA,GAAA,EAAA,CAAA,SADE;AAAA,UAEF,eAAA,GAAA,EAAA,CAAA,SAFE;AAAA,UAGF,YAAA,GAAA,EAAA,CAAA,YAHE,CAFgD,CAOtD;;AACM,UAAA,EAAA,GAAA,KAAA,qBAAA,EAAA;AAAA,UAAE,UAAA,GAAA,EAAA,CAAA,UAAF;AAAA,UAAc,aAAA,GAAA,EAAA,CAAA,aAAd,CARgD,CAUtD;;;AACA,UAAM,gBAAgB,GAAG,SAAS,GAAG,YAAZ,GAA2B,aAA3B,GAA2C,eAApE;AACA,UAAM,aAAa,GAAG,SAAS,GAAG,UAAZ,GAAyB,eAA/C;;AAEA,UAAI,gBAAgB,IAAI,eAAe,GAAG,YAA1C,EAAwD;AACpD;AACA,aAAK,cAAL,CAAoB,SAApB,GAAgC,gBAAgB,GAAG,YAAnB,GAAkC,YAAlE;AACH,OAHD,MAGO,IAAI,aAAa,IAAI,eAArB,EAAsC;AACzC;AACA,aAAK,cAAL,CAAoB,SAApB,GAAgC,aAAa,GAAG,YAAhD;AACH;AACJ;AACJ,GApCM;;AAsCA,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,GAAP,UAAgB,KAAhB,EAA+B,eAA/B,EAA0E,KAA1E,EAA4F;AAA7D,QAAA,eAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,eAAA,GAAkB,KAAK,KAAL,CAAW,YAA7B;AAAyC;;AAAE,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,KAAb;AAAkB;;AAChF,QAAA,sBAAA,GAAA,KAAA,CAAA,sBAAA;AAER,SAAK,+BAAL,GAAuC,IAAvC;AACA,QAAM,eAAe,GAAG,KAAK,KAAK,KAAK,KAAL,CAAW,KAA7C;;AACA,QAAI,eAAJ,EAAqB;AACjB,MAAA,KAAK,CAAC,UAAN,CAAiB,KAAK,CAAC,aAAvB,EAAsC,KAAtC;AACH;;AAED,QAAM,aAAa,GAAG,gBAAgB,CAAC,KAAD,EAAQ,KAAR,CAAtC;AACA,QAAM,aAAa,GACf,sBAAsB,IAAI,IAA1B,IAAkC,KAAK,KAAK,EAA5C,GAAiD,sBAAsB,CAAC,KAAD,CAAvE,GAAiF,SADrF;AAEA,SAAK,QAAL,CAAc;AAAE,MAAA,aAAa,EAAA,aAAf;AAAiB,MAAA,aAAa,EAAA,aAA9B;AAAgC,MAAA,KAAK,EAAA;AAArC,KAAd,EAZwF,CAcxF;;AACA,QAAM,WAAW,GAAG,KAAK,cAAL,CAAoB,aAApB,CAApB;AACA,QAAM,sBAAsB,GACxB,eAAe,IACf,WAAW,GAAG,CADd,IAEA,cAAc,CAAC,aAAa,CAAC,KAAK,KAAL,CAAW,UAAZ,CAAd,EAAuC,WAAvC,EAAoD,KAAK,CAAC,YAA1D,CAHlB;;AAKA,QAAI,sBAAJ,EAA4B;AACxB,WAAK,aAAL,CAAmB,mBAAmB,CAAC,aAAD,EAAgB,KAAK,CAAC,YAAtB,CAAtC;AACH;AACJ,GAxBM;;AA2EC,EAAA,SAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,YAAA;AACY,QAAA,UAAA,GAAA,KAAA,KAAA,CAAA,UAAA;;AACR,QAAI,KAAK,cAAL,IAAuB,IAA3B,EAAiC;AAC7B,UAAI,eAAe,CAAC,UAAD,CAAnB,EAAiC;AAC7B,eAAO,KAAK,cAAL,CAAoB,QAApB,CAA6B,IAA7B,CAAkC,KAAK,KAAL,CAAW,aAAX,CAAyB,MAA3D,CAAP;AACH,OAFD,MAEO;AACH,YAAM,WAAW,GAAG,KAAK,cAAL,EAApB;AACA,eAAO,KAAK,cAAL,CAAoB,QAApB,CAA6B,IAA7B,CAAkC,WAAlC,CAAP;AACH;AACJ;;AACD,WAAO,SAAP;AACH,GAXO;;AAaA,EAAA,SAAA,CAAA,SAAA,CAAA,cAAA,GAAR,UAAuB,KAAvB,EAAuD;AAAhC,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,KAAK,KAAL,CAAW,aAAnB;AAAgC;;AAC3C,QAAA,UAAA,GAAA,KAAA,KAAA,CAAA,UAAA;;AACR,QAAI,UAAU,IAAI,IAAd,IAAsB,eAAe,CAAC,UAAD,CAAzC,EAAuD;AACnD,aAAO,CAAC,CAAR;AACH,KAJkD,CAKnD;;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,EAAE,CAApC,EAAuC;AACnC,UAAI,iBAAiB,CAAC,KAAK,KAAL,CAAW,UAAZ,EAAwB,KAAK,CAAC,CAAD,CAA7B,EAAkC,UAAlC,CAArB,EAAoE;AAChE,eAAO,CAAP;AACH;AACJ;;AACD,WAAO,CAAC,CAAR;AACH,GAZO;;AAcA,EAAA,SAAA,CAAA,SAAA,CAAA,qBAAA,GAAR,YAAA;AACI;AACM,QAAA,EAAA,GAAA,gBAAA,CAAA,KAAA,cAAA,CAAA;AAAA,QAAE,UAAA,GAAA,EAAA,CAAA,UAAF;AAAA,QAAc,aAAA,GAAA,EAAA,CAAA,aAAd;;AACN,WAAO;AACH,MAAA,aAAa,EAAE,UAAU,CAAC,aAAD,CADtB;AAEH,MAAA,UAAU,EAAE,UAAU,CAAC,UAAD;AAFnB,KAAP;AAIH,GAPO;AAuGR;;;;;;;;AAMQ,EAAA,SAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,SAA1B,EAA6C,UAA7C,EAA+E;AAAlC,QAAA,UAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,UAAA,GAAa,KAAK,cAAL,EAAb;AAAkC;;AAC3E,QAAI,KAAK,oBAAL,EAAJ,EAAiC;AAC7B,UAAM,aAAa,GACd,UAAU,KAAK,CAAf,IAAoB,SAAS,KAAK,CAAC,CAApC,IACC,UAAU,KAAK,KAAK,KAAL,CAAW,aAAX,CAAyB,MAAzB,GAAkC,CAAjD,IAAsD,SAAS,KAAK,CAFzE;;AAGA,UAAI,aAAJ,EAAmB;AACf,eAAO,gBAAgB,EAAvB;AACH;AACJ;;AACD,WAAO,mBAAmB,CAAC,KAAK,KAAL,CAAW,aAAZ,EAA2B,KAAK,KAAL,CAAW,YAAtC,EAAoD,SAApD,EAA+D,UAA/D,CAA1B;AACH,GAVO;;AAYA,EAAA,SAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UAAsB,UAAtB,EAA2D;AACvD,SAAK,sBAAL,GAA8B,UAA9B;;AACA,QAAI,KAAK,KAAL,CAAW,UAAX,KAA0B,SAA9B,EAAyC;AACrC;AACA,WAAK,+BAAL,GAAuC,IAAvC;AACA,WAAK,QAAL,CAAc;AAAE,QAAA,UAAU,EAAA;AAAZ,OAAd;AACH;;AAED,QAAI,eAAe,CAAC,UAAD,CAAnB,EAAiC;AAC7B,MAAA,KAAK,CAAC,UAAN,CAAiB,KAAK,KAAL,CAAW,kBAA5B,EAAgD,IAAhD,EAAsD,IAAtD;AACH,KAFD,MAEO;AACH,MAAA,KAAK,CAAC,UAAN,CAAiB,KAAK,KAAL,CAAW,kBAA5B,EAAgD,UAAhD,EAA4D,KAA5D;AACH;AACJ,GAbO;;AAeA,EAAA,SAAA,CAAA,SAAA,CAAA,oBAAA,GAAR,YAAA;AACI,WACI,KAAK,cAAL,MACA,KAAK,KAAL,CAAW,KAAX,KAAqB,EADrB,IAEA;AACA;AACA;AACA,KAAC,KAAK,qCAAL,EANL;AAQH,GATO;;AAWA,EAAA,SAAA,CAAA,SAAA,CAAA,cAAA,GAAR,YAAA;AACI,WAAO,KAAK,KAAL,CAAW,sBAAX,IAAqC,IAArC,IAA6C,KAAK,KAAL,CAAW,qBAAX,IAAoC,IAAxF;AACH,GAFO;;AAIA,EAAA,SAAA,CAAA,SAAA,CAAA,qCAAA,GAAR,YAAA;AAAA,QAAA,KAAA,GAAA,IAAA,CAAA,CACI;AACA;;;AACA,WAAO,KAAK,KAAL,CAAW,aAAX,CAAyB,IAAzB,CAA8B,UAAA,IAAA,EAAI;AACrC,aAAA,iBAAiB,CAAC,KAAI,CAAC,KAAL,CAAW,UAAZ,EAAwB,IAAxB,EAA8B,KAAI,CAAC,KAAL,CAAW,aAAzC,CAAjB;AAAwE,KADrE,CAAP;AAGH,GANO;;AAlYM,EAAA,SAAA,CAAA,WAAA,GAAiB,kBAAkB,GAAA,YAAnC;AAEA,EAAA,SAAA,CAAA,YAAA,GAAe;AACzB,IAAA,QAAQ,EAAE,KADe;AAEzB,IAAA,YAAY,EAAE;AAFW,GAAf;AAuYlB,SAAA,SAAA;AAAC,CA1YD,CAAkC,kBAAlC,CAAA;;SAAa,S;;AA4Yb,SAAS,UAAT,CAAoB,KAApB,EAAwC;AACpC,SAAO,KAAK,IAAI,IAAT,GAAgB,CAAhB,GAAoB,QAAQ,CAAC,KAAK,CAAC,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAAD,EAAqB,EAArB,CAAnC;AACH;;AAED,SAAS,eAAT,CAA4B,KAA5B,EAA2C,EAA3C,EAAuF;MAA1C,KAAA,GAAA,EAAA,CAAA,K;MAAO,aAAA,GAAA,EAAA,CAAA,a;;AAChD,MAAI,KAAK,CAAC,UAAN,CAAiB,aAAjB,CAAJ,EAAqC;AACjC;AACA;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACnC,UAAM,IAAI,GAAG,KAAK,CAAC,CAAD,CAAlB;;AACA,UAAI,aAAa,CAAC,KAAD,EAAQ,IAAR,EAAc,CAAd,EAAiB,IAAjB,CAAjB,EAAyC;AACrC,eAAO,IAAP;AACH;AACJ;AACJ;;AACD,SAAO,SAAP;AACH;;AAED,SAAS,gBAAT,CAA6B,KAA7B,EAA4C,EAA5C,EAA2G;MAA7D,KAAA,GAAA,EAAA,CAAA,K;MAAO,aAAA,GAAA,EAAA,CAAA,a;MAAe,iBAAA,GAAA,EAAA,CAAA,iB;;AAChE,MAAI,KAAK,CAAC,UAAN,CAAiB,iBAAjB,CAAJ,EAAyC;AACrC;AACA,WAAO,iBAAiB,CAAC,KAAD,EAAQ,KAAR,CAAxB;AACH,GAHD,MAGO,IAAI,KAAK,CAAC,UAAN,CAAiB,aAAjB,CAAJ,EAAqC;AACxC,WAAO,KAAK,CAAC,MAAN,CAAa,UAAC,IAAD,EAAO,KAAP,EAAY;AAAK,aAAA,aAAa,CAAC,KAAD,EAAQ,IAAR,EAAb,KAAa,CAAb;AAAiC,KAA/D,CAAP;AACH;;AACD,SAAO,KAAP;AACH;AAED;;;AACA,SAAS,UAAT,CAAoB,KAApB,EAAmC,GAAnC,EAAgD,GAAhD,EAA2D;AACvD,MAAI,KAAK,GAAG,GAAZ,EAAiB;AACb,WAAO,GAAP;AACH,GAFD,MAEO,IAAI,KAAK,GAAG,GAAZ,EAAiB;AACpB,WAAO,GAAP;AACH;;AACD,SAAO,KAAP;AACH;;AAED,SAAS,cAAT,CAA2B,IAA3B,EAA2C,KAA3C,EAA0D,YAA1D,EAA2G;AACvG,MAAI,YAAY,IAAI,IAAhB,IAAwB,IAAI,IAAI,IAApC,EAA0C;AACtC,WAAO,KAAP;AACH,GAFD,MAEO,IAAI,KAAK,CAAC,UAAN,CAAiB,YAAjB,CAAJ,EAAoC;AACvC,WAAO,YAAY,CAAC,IAAD,EAAO,KAAP,CAAnB;AACH;;AACD,SAAO,CAAC,CAAC,IAAI,CAAC,YAAD,CAAb;AACH;AAED;;;;;;;;;;AAQA,OAAM,SAAU,mBAAV,CACF,KADE,EAEF,YAFE,EAGF,SAHE,EAIF,UAJE,EAI2B;AAD7B,MAAA,SAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,SAAA,GAAA,CAAA;AAAa;;AACb,MAAA,UAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,UAAA,GAAa,KAAK,CAAC,MAAN,GAAe,CAA5B;AAA6B;;AAE7B,MAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACpB,WAAO,IAAP;AACH,GAJ4B,CAK7B;;;AACA,MAAI,KAAK,GAAG,UAAZ;AACA,MAAM,QAAQ,GAAG,KAAK,CAAC,MAAN,GAAe,CAAhC;;AACA,KAAG;AACC;AACA,IAAA,KAAK,GAAG,UAAU,CAAC,KAAK,GAAG,SAAT,EAAoB,CAApB,EAAuB,QAAvB,CAAlB;;AACA,QAAI,CAAC,cAAc,CAAC,KAAK,CAAC,KAAD,CAAN,EAAe,KAAf,EAAsB,YAAtB,CAAnB,EAAwD;AACpD,aAAO,KAAK,CAAC,KAAD,CAAZ;AACH;AACJ,GAND,QAMS,KAAK,KAAK,UAAV,IAAwB,UAAU,KAAK,CAAC,CANjD;;AAOA,SAAO,IAAP;AACH","sourceRoot":"","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport * as React from \"react\";\nimport { AbstractComponent2, DISPLAYNAME_PREFIX, Keys, Menu, Utils } from \"@blueprintjs/core\";\nimport { executeItemsEqual, getActiveItem, getCreateNewItem, isCreateNewItem, renderFilteredItems, } from \"../../common\";\nvar QueryList = /** @class */ (function (_super) {\n    tslib_1.__extends(QueryList, _super);\n    function QueryList(props, context) {\n        var _this = _super.call(this, props, context) || this;\n        _this.refHandlers = {\n            itemsParent: function (ref) { return (_this.itemsParentRef = ref); },\n        };\n        /**\n         * Flag indicating that we should check whether selected item is in viewport\n         * after rendering, typically because of keyboard change. Set to `true` when\n         * manipulating state in a way that may cause active item to scroll away.\n         */\n        _this.shouldCheckActiveItemInViewport = false;\n        /**\n         * The item that we expect to be the next selected active item (based on click\n         * or key interactions). When scrollToActiveItem = false, used to detect if\n         * an unexpected external change to the active item has been made.\n         */\n        _this.expectedNextActiveItem = null;\n        /** default `itemListRenderer` implementation */\n        _this.renderItemList = function (listProps) {\n            var _a = _this.props, initialContent = _a.initialContent, noResults = _a.noResults;\n            // omit noResults if createNewItemFromQuery and createNewItemRenderer are both supplied, and query is not empty\n            var maybeNoResults = _this.isCreateItemRendered() ? null : noResults;\n            var menuContent = renderFilteredItems(listProps, maybeNoResults, initialContent);\n            var createItemView = _this.isCreateItemRendered() ? _this.renderCreateItemMenuItem(_this.state.query) : null;\n            if (menuContent == null && createItemView == null) {\n                return null;\n            }\n            return (React.createElement(Menu, { ulRef: listProps.itemsParentRef },\n                menuContent,\n                createItemView));\n        };\n        /** wrapper around `itemRenderer` to inject props */\n        _this.renderItem = function (item, index) {\n            if (_this.props.disabled !== true) {\n                var _a = _this.state, activeItem = _a.activeItem, query = _a.query;\n                var matchesPredicate = _this.state.filteredItems.indexOf(item) >= 0;\n                var modifiers = {\n                    active: executeItemsEqual(_this.props.itemsEqual, getActiveItem(activeItem), item),\n                    disabled: isItemDisabled(item, index, _this.props.itemDisabled),\n                    matchesPredicate: matchesPredicate,\n                };\n                return _this.props.itemRenderer(item, {\n                    handleClick: function (e) { return _this.handleItemSelect(item, e); },\n                    index: index,\n                    modifiers: modifiers,\n                    query: query,\n                });\n            }\n            return null;\n        };\n        _this.renderCreateItemMenuItem = function (query) {\n            var activeItem = _this.state.activeItem;\n            var handleClick = function (evt) {\n                _this.handleItemCreate(query, evt);\n            };\n            var isActive = isCreateNewItem(activeItem);\n            return Utils.safeInvoke(_this.props.createNewItemRenderer, query, isActive, handleClick);\n        };\n        _this.handleItemCreate = function (query, evt) {\n            // we keep a cached createNewItem in state, but might as well recompute\n            // the result just to be sure it's perfectly in sync with the query.\n            var item = Utils.safeInvoke(_this.props.createNewItemFromQuery, query);\n            if (item != null) {\n                Utils.safeInvoke(_this.props.onItemSelect, item, evt);\n                _this.setQuery(\"\", true);\n            }\n        };\n        _this.handleItemSelect = function (item, event) {\n            _this.setActiveItem(item);\n            Utils.safeInvoke(_this.props.onItemSelect, item, event);\n            if (_this.props.resetOnSelect) {\n                _this.setQuery(\"\", true);\n            }\n        };\n        _this.handlePaste = function (queries) {\n            var _a = _this.props, createNewItemFromQuery = _a.createNewItemFromQuery, onItemsPaste = _a.onItemsPaste;\n            var nextActiveItem;\n            var nextQueries = [];\n            // Find an exising item that exactly matches each pasted value, or\n            // create a new item if possible. Ignore unmatched values if creating\n            // items is disabled.\n            var pastedItemsToEmit = [];\n            for (var _i = 0, queries_1 = queries; _i < queries_1.length; _i++) {\n                var query = queries_1[_i];\n                var equalItem = getMatchingItem(query, _this.props);\n                if (equalItem !== undefined) {\n                    nextActiveItem = equalItem;\n                    pastedItemsToEmit.push(equalItem);\n                }\n                else if (_this.canCreateItems()) {\n                    var newItem = Utils.safeInvoke(createNewItemFromQuery, query);\n                    if (newItem !== undefined) {\n                        pastedItemsToEmit.push(newItem);\n                    }\n                }\n                else {\n                    nextQueries.push(query);\n                }\n            }\n            // UX nicety: combine all unmatched queries into a single\n            // comma-separated query in the input, so we don't lose any information.\n            // And don't reset the active item; we'll do that ourselves below.\n            _this.setQuery(nextQueries.join(\", \"), false);\n            // UX nicety: update the active item if we matched with at least one\n            // existing item.\n            if (nextActiveItem !== undefined) {\n                _this.setActiveItem(nextActiveItem);\n            }\n            Utils.safeInvoke(onItemsPaste, pastedItemsToEmit);\n        };\n        _this.handleKeyDown = function (event) {\n            var keyCode = event.keyCode;\n            if (keyCode === Keys.ARROW_UP || keyCode === Keys.ARROW_DOWN) {\n                event.preventDefault();\n                var nextActiveItem = _this.getNextActiveItem(keyCode === Keys.ARROW_UP ? -1 : 1);\n                if (nextActiveItem != null) {\n                    _this.setActiveItem(nextActiveItem);\n                }\n            }\n            Utils.safeInvoke(_this.props.onKeyDown, event);\n        };\n        _this.handleKeyUp = function (event) {\n            var onKeyUp = _this.props.onKeyUp;\n            var activeItem = _this.state.activeItem;\n            // using keyup for enter to play nice with Button's keyboard clicking.\n            // if we were to process enter on keydown, then Button would click itself on keyup\n            // and the popvoer would re-open out of our control :(.\n            if (event.keyCode === Keys.ENTER) {\n                event.preventDefault();\n                if (activeItem == null || isCreateNewItem(activeItem)) {\n                    _this.handleItemCreate(_this.state.query, event);\n                }\n                else {\n                    _this.handleItemSelect(activeItem, event);\n                }\n            }\n            Utils.safeInvoke(onKeyUp, event);\n        };\n        _this.handleQueryChange = function (event) {\n            var query = event == null ? \"\" : event.target.value;\n            _this.setQuery(query);\n            Utils.safeInvoke(_this.props.onQueryChange, query, event);\n        };\n        var _a = props.query, query = _a === void 0 ? \"\" : _a;\n        var createNewItem = Utils.safeInvoke(props.createNewItemFromQuery, query);\n        var filteredItems = getFilteredItems(query, props);\n        _this.state = {\n            activeItem: props.activeItem !== undefined\n                ? props.activeItem\n                : getFirstEnabledItem(filteredItems, props.itemDisabled),\n            createNewItem: createNewItem,\n            filteredItems: filteredItems,\n            query: query,\n        };\n        return _this;\n    }\n    QueryList.ofType = function () {\n        return QueryList;\n    };\n    QueryList.prototype.render = function () {\n        var _a = this.props, className = _a.className, items = _a.items, renderer = _a.renderer, _b = _a.itemListRenderer, itemListRenderer = _b === void 0 ? this.renderItemList : _b;\n        var _c = this.state, createNewItem = _c.createNewItem, spreadableState = tslib_1.__rest(_c, [\"createNewItem\"]);\n        return renderer(tslib_1.__assign({}, spreadableState, { className: className, handleItemSelect: this.handleItemSelect, handleKeyDown: this.handleKeyDown, handleKeyUp: this.handleKeyUp, handlePaste: this.handlePaste, handleQueryChange: this.handleQueryChange, itemList: itemListRenderer(tslib_1.__assign({}, spreadableState, { items: items, itemsParentRef: this.refHandlers.itemsParent, renderItem: this.renderItem })) }));\n    };\n    QueryList.prototype.componentDidUpdate = function (prevProps) {\n        var _this = this;\n        if (this.props.activeItem !== undefined && this.props.activeItem !== this.state.activeItem) {\n            this.shouldCheckActiveItemInViewport = true;\n            this.setState({ activeItem: this.props.activeItem });\n        }\n        if (this.props.query != null && this.props.query !== prevProps.query) {\n            // new query\n            this.setQuery(this.props.query, this.props.resetOnQuery, this.props);\n        }\n        else if (\n        // same query (or uncontrolled query), but items in the list changed\n        !Utils.shallowCompareKeys(this.props, prevProps, {\n            include: [\"items\", \"itemListPredicate\", \"itemPredicate\"],\n        })) {\n            this.setQuery(this.state.query);\n        }\n        if (this.shouldCheckActiveItemInViewport) {\n            // update scroll position immediately before repaint so DOM is accurate\n            // (latest filteredItems) and to avoid flicker.\n            requestAnimationFrame(function () { return _this.scrollActiveItemIntoView(); });\n            // reset the flag\n            this.shouldCheckActiveItemInViewport = false;\n        }\n    };\n    QueryList.prototype.scrollActiveItemIntoView = function () {\n        var scrollToActiveItem = this.props.scrollToActiveItem !== false;\n        var externalChangeToActiveItem = !executeItemsEqual(this.props.itemsEqual, getActiveItem(this.expectedNextActiveItem), getActiveItem(this.props.activeItem));\n        this.expectedNextActiveItem = null;\n        if (!scrollToActiveItem && externalChangeToActiveItem) {\n            return;\n        }\n        var activeElement = this.getActiveElement();\n        if (this.itemsParentRef != null && activeElement != null) {\n            var activeTop = activeElement.offsetTop, activeHeight = activeElement.offsetHeight;\n            var _a = this.itemsParentRef, parentOffsetTop = _a.offsetTop, parentScrollTop = _a.scrollTop, parentHeight = _a.clientHeight;\n            // compute padding on parent element to ensure we always leave space\n            var _b = this.getItemsParentPadding(), paddingTop = _b.paddingTop, paddingBottom = _b.paddingBottom;\n            // compute the two edges of the active item for comparison, including parent padding\n            var activeBottomEdge = activeTop + activeHeight + paddingBottom - parentOffsetTop;\n            var activeTopEdge = activeTop - paddingTop - parentOffsetTop;\n            if (activeBottomEdge >= parentScrollTop + parentHeight) {\n                // offscreen bottom: align bottom of item with bottom of viewport\n                this.itemsParentRef.scrollTop = activeBottomEdge + activeHeight - parentHeight;\n            }\n            else if (activeTopEdge <= parentScrollTop) {\n                // offscreen top: align top of item with top of viewport\n                this.itemsParentRef.scrollTop = activeTopEdge - activeHeight;\n            }\n        }\n    };\n    QueryList.prototype.setQuery = function (query, resetActiveItem, props) {\n        if (resetActiveItem === void 0) { resetActiveItem = this.props.resetOnQuery; }\n        if (props === void 0) { props = this.props; }\n        var createNewItemFromQuery = props.createNewItemFromQuery;\n        this.shouldCheckActiveItemInViewport = true;\n        var hasQueryChanged = query !== this.state.query;\n        if (hasQueryChanged) {\n            Utils.safeInvoke(props.onQueryChange, query);\n        }\n        var filteredItems = getFilteredItems(query, props);\n        var createNewItem = createNewItemFromQuery != null && query !== \"\" ? createNewItemFromQuery(query) : undefined;\n        this.setState({ createNewItem: createNewItem, filteredItems: filteredItems, query: query });\n        // always reset active item if it's now filtered or disabled\n        var activeIndex = this.getActiveIndex(filteredItems);\n        var shouldUpdateActiveItem = resetActiveItem ||\n            activeIndex < 0 ||\n            isItemDisabled(getActiveItem(this.state.activeItem), activeIndex, props.itemDisabled);\n        if (shouldUpdateActiveItem) {\n            this.setActiveItem(getFirstEnabledItem(filteredItems, props.itemDisabled));\n        }\n    };\n    QueryList.prototype.getActiveElement = function () {\n        var activeItem = this.state.activeItem;\n        if (this.itemsParentRef != null) {\n            if (isCreateNewItem(activeItem)) {\n                return this.itemsParentRef.children.item(this.state.filteredItems.length);\n            }\n            else {\n                var activeIndex = this.getActiveIndex();\n                return this.itemsParentRef.children.item(activeIndex);\n            }\n        }\n        return undefined;\n    };\n    QueryList.prototype.getActiveIndex = function (items) {\n        if (items === void 0) { items = this.state.filteredItems; }\n        var activeItem = this.state.activeItem;\n        if (activeItem == null || isCreateNewItem(activeItem)) {\n            return -1;\n        }\n        // NOTE: this operation is O(n) so it should be avoided in render(). safe for events though.\n        for (var i = 0; i < items.length; ++i) {\n            if (executeItemsEqual(this.props.itemsEqual, items[i], activeItem)) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    QueryList.prototype.getItemsParentPadding = function () {\n        // assert ref exists because it was checked before calling\n        var _a = getComputedStyle(this.itemsParentRef), paddingTop = _a.paddingTop, paddingBottom = _a.paddingBottom;\n        return {\n            paddingBottom: pxToNumber(paddingBottom),\n            paddingTop: pxToNumber(paddingTop),\n        };\n    };\n    /**\n     * Get the next enabled item, moving in the given direction from the start\n     * index. A `null` return value means no suitable item was found.\n     * @param direction amount to move in each iteration, typically +/-1\n     * @param startIndex item to start iteration\n     */\n    QueryList.prototype.getNextActiveItem = function (direction, startIndex) {\n        if (startIndex === void 0) { startIndex = this.getActiveIndex(); }\n        if (this.isCreateItemRendered()) {\n            var reachedCreate = (startIndex === 0 && direction === -1) ||\n                (startIndex === this.state.filteredItems.length - 1 && direction === 1);\n            if (reachedCreate) {\n                return getCreateNewItem();\n            }\n        }\n        return getFirstEnabledItem(this.state.filteredItems, this.props.itemDisabled, direction, startIndex);\n    };\n    QueryList.prototype.setActiveItem = function (activeItem) {\n        this.expectedNextActiveItem = activeItem;\n        if (this.props.activeItem === undefined) {\n            // indicate that the active item may need to be scrolled into view after update.\n            this.shouldCheckActiveItemInViewport = true;\n            this.setState({ activeItem: activeItem });\n        }\n        if (isCreateNewItem(activeItem)) {\n            Utils.safeInvoke(this.props.onActiveItemChange, null, true);\n        }\n        else {\n            Utils.safeInvoke(this.props.onActiveItemChange, activeItem, false);\n        }\n    };\n    QueryList.prototype.isCreateItemRendered = function () {\n        return (this.canCreateItems() &&\n            this.state.query !== \"\" &&\n            // this check is unfortunately O(N) on the number of items, but\n            // alas, hiding the \"Create Item\" option when it exactly matches an\n            // existing item is much clearer.\n            !this.wouldCreatedItemMatchSomeExistingItem());\n    };\n    QueryList.prototype.canCreateItems = function () {\n        return this.props.createNewItemFromQuery != null && this.props.createNewItemRenderer != null;\n    };\n    QueryList.prototype.wouldCreatedItemMatchSomeExistingItem = function () {\n        var _this = this;\n        // search only the filtered items, not the full items list, because we\n        // only need to check items that match the current query.\n        return this.state.filteredItems.some(function (item) {\n            return executeItemsEqual(_this.props.itemsEqual, item, _this.state.createNewItem);\n        });\n    };\n    QueryList.displayName = DISPLAYNAME_PREFIX + \".QueryList\";\n    QueryList.defaultProps = {\n        disabled: false,\n        resetOnQuery: true,\n    };\n    return QueryList;\n}(AbstractComponent2));\nexport { QueryList };\nfunction pxToNumber(value) {\n    return value == null ? 0 : parseInt(value.slice(0, -2), 10);\n}\nfunction getMatchingItem(query, _a) {\n    var items = _a.items, itemPredicate = _a.itemPredicate;\n    if (Utils.isFunction(itemPredicate)) {\n        // .find() doesn't exist in ES5. Alternative: use a for loop instead of\n        // .filter() so that we can return as soon as we find the first match.\n        for (var i = 0; i < items.length; i++) {\n            var item = items[i];\n            if (itemPredicate(query, item, i, true)) {\n                return item;\n            }\n        }\n    }\n    return undefined;\n}\nfunction getFilteredItems(query, _a) {\n    var items = _a.items, itemPredicate = _a.itemPredicate, itemListPredicate = _a.itemListPredicate;\n    if (Utils.isFunction(itemListPredicate)) {\n        // note that implementations can reorder the items here\n        return itemListPredicate(query, items);\n    }\n    else if (Utils.isFunction(itemPredicate)) {\n        return items.filter(function (item, index) { return itemPredicate(query, item, index); });\n    }\n    return items;\n}\n/** Wrap number around min/max values: if it exceeds one bound, return the other. */\nfunction wrapNumber(value, min, max) {\n    if (value < min) {\n        return max;\n    }\n    else if (value > max) {\n        return min;\n    }\n    return value;\n}\nfunction isItemDisabled(item, index, itemDisabled) {\n    if (itemDisabled == null || item == null) {\n        return false;\n    }\n    else if (Utils.isFunction(itemDisabled)) {\n        return itemDisabled(item, index);\n    }\n    return !!item[itemDisabled];\n}\n/**\n * Get the next enabled item, moving in the given direction from the start\n * index. A `null` return value means no suitable item was found.\n * @param items the list of items\n * @param itemDisabled callback to determine if a given item is disabled\n * @param direction amount to move in each iteration, typically +/-1\n * @param startIndex which index to begin moving from\n */\nexport function getFirstEnabledItem(items, itemDisabled, direction, startIndex) {\n    if (direction === void 0) { direction = 1; }\n    if (startIndex === void 0) { startIndex = items.length - 1; }\n    if (items.length === 0) {\n        return null;\n    }\n    // remember where we started to prevent an infinite loop\n    var index = startIndex;\n    var maxIndex = items.length - 1;\n    do {\n        // find first non-disabled item\n        index = wrapNumber(index + direction, 0, maxIndex);\n        if (!isItemDisabled(items[index], index, itemDisabled)) {\n            return items[index];\n        }\n    } while (index !== startIndex && startIndex !== -1);\n    return null;\n}\n//# sourceMappingURL=queryList.js.map"]},"metadata":{},"sourceType":"module"}